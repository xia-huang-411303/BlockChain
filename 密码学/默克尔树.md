1979年瑞夫·默克尔（RalphMerkle）申请了默克尔树（ #MerkleTree ）专利， 原用于生成数字证书目录的摘要，后来提出了很多种改进，比特币使用了最简单的 #默克尔二叉树 。

默克尔树本质上是一种哈希树，每个结点都是哈希值。
通过哈希构建默克尔树，可以实现内容改变的快速检测。

在区块链中默克尔树根哈希就是当前区块所有交易信息的一个哈希值，但是这个哈希值并不是直接将所有交易内容计算得到的哈希，而是通过 #哈希二叉树 计算得到。
首先，对每笔交易计算哈希值；
然后，进行两两分组，并对这两个哈希值计算得到一个新的哈希值，两个旧的哈希值就作为新哈希值的叶子节点，如果哈希数量为单数，则对最后一个哈希值再次计算哈希值即可；
重复上述计算，直至最后只剩一个哈希值，这就是默克尔树的根哈希，即 #交易默克尔根 （ #MerkleRoot ）。
下图为区块头中默克尔树根哈希的计算示意图，此处仅体现哈希相关的关键信息。
![[区块哈希相连示意图.png|300]]

结合哈希算法输入敏感的特点，块内任何交易数据的篡改都会导致计算的 默克尔根 的哈希值与之前不同。因此可以通过 #默克尔根 快速比较两个区块中存储的交易是否完全一致，从而快速识别某交易是否被篡改，进而确保交易数据的完整性。

因为默克尔二叉树是二叉树，找出两个默克尔树的差异点的算法复杂度为 O(log(n))。
另外，无须树上其他结点参与，仅根据交易结点到默克尔根路径上的直接分支，即可基于 #简单支付验证 （Simplified Payment Verification， #SPV ）确认一个交易是否存在于该块。

默克尔树在生活中其他领域的应用也非常广泛。例如，BT下载，数据一般会分成很多个小块，以保证快速下载。在下载前，先下载一个该文件的默克尔树，下载完成后重新生成默克尔树进行对比校验。若校验不通过，可根据默克尔树快速定位损坏的数据块，重新下载即可。