1999年，BarbaraLiskov等提出了 #实用拜占庭容错 算法，解决了 #异步网络 环境下拜占庭容错算法效率不高的问题，使得拜占庭容错算法在实际系统应用中变得可行。

#PBFT 是拜占庭算法发展史的里程碑，但以现在的眼光来看，仍然有几点不足。首先，PBFT算法需要预知节点的数量，难以动态管理，无法满足公有链场景下节点自由进出的需求；其次，对于节点数为$n$的集群，PBFT消息复杂度为$O(n^2)$，性能会随着节点数量的增加迅速下降，难以应用于大规模的共识场景。

### 关键概念
在PBFT算法中，有以下几个关键概念：
- #Primary ：集群主节点，也称为Leader节点，负责对客户端发来的交易请求进行排序(工程实现中通常还有对交易打包出块的功能，通过批处理提升系统性能)。
- #Replica ：副本节点，其状态机与主节点保持同步。
- #Transaction ：交易，在区块链中通常指由客户端发起的操作请求。
- #View ：视图，PBFT中配置状态，关键信息是集群当前由哪个节点担任Primary角色。集群中在多数节点投票确认当前Primary节点异常时，会执行切换Primary节点的流程，此配置状态的更新流程也被称为 #视图转换 （ViewChange）。
- #quorum ：完成 #Prepare 与 #Commit 阶段需要的相同消息数, 且  ${quorum>\frac{N+f}{2}}$。其中，$f$ 为能容忍的拜占庭节点数量，${N}$ 为集群结点的数量，且 ${N>3f}$ (工程中常取 ${N \geqslant 3 f+1}$ )。

### 主要流程
PBFT算法的主要流程如下：
![[实用拜占庭算法的共识流程.png|400]]
#### Request阶段
Client客户端发送交易请求至集群Primary节点，若交易被误发送到Replica节点，则会转发给Primary节点。
#### PrePrepare阶段
Primary节点收到Client发送的交易请求后，会执行验证、打包、排序流程操作。
#交易验证 ：Primary节点会对客户端发来的交易进行合法认证与查重，通过验证的交易会顺序进入Primary缓存中，等待打包。
#交易打包 ：Primary节点将缓存中顺序排列的交易打包成一组，进而通过批处理的方式降低通信开销，提高系统性能。打包的策略通常有两种，分别是按交易数量打包与超过超时时间打包。当缓存的交易数目达到设定的区块最大交易数量阈值，或达到设定的超时时间，缓存仍有少量交易，都会触发打包操作。
#交易排序 ：Primary节点会对打包后的交易分配一个顺序递增的编号(SequenceNumber，SN)，进而可以确保集群中的Replica节点按相同的顺序执行交易，不会因网络故障等原因打乱提交次序。

#### Prepare阶段
Replica节点会对主节点发送的Pre-Prepare消息进行合法性检查，若检查通过，就会向其他共识节点广播Prepare消息内容，进行交叉验证；若检查不通过则不发送消息。若系统中多数节点不发送Prepare消息，则会导致后续环节无法正常进行，此次交易超时乃至触发视图切换。
#### Commit阶段
Replica节点会对收到的Prepare消息内容与缓存中Pre-Rrepare消息内容的一致性进行检查。若收到(quorum－1)个与Pre-Prepare内容一致的Prepare消息，证明Primary节点可靠，且集群节点能对账本数据达成一致，可以广播Commit消息表示本节点可以执行交易；若超时时间内未能收到足够多内容一致的Prepare消息，则存在Primary节点作恶的可能，会广播View-Change消息，申请切换Primary节点。
#### Reply阶段
Replica节点会对收到的Commit消息内容与缓存中Prepare消息内容的一致性进行检查。若收到quorum个与Prepare内容一致的Commit消息，说明集群中大多数节点已经准备好执行交易，因此可以将执行结果写入本地账本，并向客户端反馈交易结果。客户端若能在超时时间内收到f+1个内容一致的执行结果，则本轮交易正常结束；若客户端未能收到足够多个一致反馈，则认为主节点可能存在异常，会向集群中所有节点再次广播Request消息，便于所有Replica节点共同验证Primary节点的可靠性。

### PBFT算法的约束
PBFT算法要求总节点数满足约束$N≥3f+1$，在部署能容忍$f$个拜占庭节点的共识集群时，总节点规模至少为$3f+1$。这是为什么呢？由于集群中可能存在f个拜占庭节点通过拒绝投票阻碍共识流程，因此PBFT在收到的$N－f$个投票后就进行统计，而不会等待所有节点的投票消息。这保证共识能正常进行，但也存在将网络延迟较大的正常节点投票丢弃的可能。最差情况下，丢弃的投票都来自诚实节点，而N－f张投票中有f个拜占庭投票，$N－2f$张诚实节点投票。显然，要得到正确的投票结论，需要诚实节点投票占大多数，因此$N－2f＞f$。工程上，PBFT算法通常取总节点数$N≥3f+1$，来杜绝拜占庭节点通过拒绝投票与错误投票的手段干扰共识进程的风险，基于PBFT发展而来的共识算法多数都沿用了这一约束。
同样影响深远的还有PBFT中对于  ${quorum>\frac{N+f}{2}}$的约束。避免拜占庭节点通过向不同节点发送不同内容的投票，造成集群分裂的可能。我们可以通过反证法来理解，假设由于拜占庭节点发送不同消息，导致集群节点n1收到quorum个投票消息＜m＞，同时n2收到quorum个投票消息＜m′＞，n1与n2执行不同操作，导致集群分裂。由于收到的2×quorum个消息来自至多N个投票节点，且${quorum>\frac{N+f}{2}}$，必然有超过$f$个节点同时发送＜m＞与＜m′＞。因拜占庭节点总数不超过$f$，则说明有诚实节点也同时发送＜m＞与＜m′＞，这显然与算法基本假设相悖。可见，${quorum>\frac{N+f}{2}}$能够有效避免集群分裂的风险。在实际工程中，可以取${quorum =\left[\frac{N+f}{2}\right]+1}$，至于工程中另一种常见形式$quorum＝2f+1$，正是总节点数取$N＝3f+1$时的特例。
